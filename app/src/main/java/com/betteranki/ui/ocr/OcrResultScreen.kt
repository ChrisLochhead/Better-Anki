package com.betteranki.ui.ocr

import androidx.compose.foundation.BorderStroke
import androidx.compose.foundation.background
import androidx.compose.foundation.border
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.ArrowBack
import androidx.compose.material.icons.filled.AutoAwesome
import androidx.compose.material.icons.filled.Check
import androidx.compose.material.icons.filled.Close
import androidx.compose.material.icons.filled.Translate
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.lifecycle.viewmodel.compose.viewModel
import com.betteranki.data.model.TranslationState
import com.betteranki.ui.theme.AppColors
import kotlinx.coroutines.launch

@OptIn(ExperimentalMaterial3Api::class, ExperimentalLayoutApi::class)
@Composable
fun OcrResultScreen(
    deckId: Long,
    recognizedText: String,
    onBack: () -> Unit,
    onCardCreated: () -> Unit,
    repository: com.betteranki.data.repository.AnkiRepository,
    preferencesRepository: com.betteranki.data.preferences.PreferencesRepository
) {
    val context = androidx.compose.ui.platform.LocalContext.current
    val viewModel: OcrViewModel = viewModel(
        factory = OcrViewModelFactory(context)
    )
    val deckListViewModel: com.betteranki.ui.decklist.DeckListViewModel = viewModel(
        factory = com.betteranki.DeckListViewModelFactory(repository)
    )
    
    // Get translation language settings
    val settings by preferencesRepository.currentSettings.collectAsState(
        initial = com.betteranki.data.model.StudySettings()
    )
    var targetLanguage by remember { mutableStateOf(settings.ocrTargetLanguage) }
    
    // Update targetLanguage when settings change
    LaunchedEffect(settings.ocrTargetLanguage) {
        targetLanguage = settings.ocrTargetLanguage
    }
    
    val translationState by viewModel.translationState.collectAsState()
    var selectedWord by remember { mutableStateOf<String?>(null) }
    var selectedWords by remember { mutableStateOf<Set<String>>(emptySet()) }
    var isManualSelectionMode by remember { mutableStateOf(false) }
    var showCardDialog by remember { mutableStateOf(false) }
    var showAutoGenerateDialog by remember { mutableStateOf(false) }
    var showBatchReview by remember { mutableStateOf(false) }
    var manualGenerationParams by remember { mutableStateOf<Triple<String, String, ExampleType>?>(null) }
    var generatedCards by remember { mutableStateOf<List<GeneratedCard>>(emptyList()) }
    var batchSourceLang by remember { mutableStateOf("") }
    var batchTargetLang by remember { mutableStateOf("") }
    var cardFront by remember { mutableStateOf("") }
    var cardExample by remember { mutableStateOf("") }
    var cardBack by remember { mutableStateOf("") }
    
    val scope = rememberCoroutineScope()
    
    // Show OCR output as one paragraph (stable order, no sentence splitting).
    val sentences = remember(recognizedText) {
        listOf(
            recognizedText
                .replace(Regex("\\s+"), " ")
                .trim()
        ).filter { it.isNotBlank() }
    }

    val handleBackOrDone: () -> Unit = {
        when {
            showBatchReview -> showBatchReview = false
            showAutoGenerateDialog -> showAutoGenerateDialog = false
            isManualSelectionMode -> {
                isManualSelectionMode = false
                selectedWords = emptySet()
                manualGenerationParams = null
            }
            else -> onBack()
        }
    }
    
    Scaffold(
        topBar = {
            TopAppBar(
                title = {
                    Text(
                        text = "SELECT TEXT",
                        fontSize = 20.sp,
                        fontWeight = FontWeight.Black,
                        letterSpacing = 3.sp
                    )
                },
                navigationIcon = {
                    IconButton(onClick = handleBackOrDone) {
                        Icon(
                            imageVector = Icons.Default.ArrowBack,
                            contentDescription = "Back",
                            tint = AppColors.TextPrimary
                        )
                    }
                },
                actions = {
                    IconButton(onClick = { showAutoGenerateDialog = true }) {
                        Icon(
                            imageVector = Icons.Default.AutoAwesome,
                            contentDescription = "Auto-generate cards",
                            tint = AppColors.TextPrimary
                        )
                    }
                },
                colors = TopAppBarDefaults.topAppBarColors(
                    containerColor = AppColors.DarkSurface,
                    titleContentColor = AppColors.TextPrimary
                )
            )
        },
        containerColor = AppColors.DarkBackground
    ) { paddingValues ->
        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(paddingValues)
                .padding(16.dp)
        ) {
            // Instructions
            Text(
                text = if (isManualSelectionMode) "SELECT WORDS FOR FLASHCARDS (${selectedWords.size} SELECTED)" else "TAP ANY WORD TO CREATE A FLASHCARD",
                fontSize = 12.sp,
                fontWeight = FontWeight.Bold,
                color = AppColors.TextPrimary.copy(alpha = 0.7f),
                letterSpacing = 1.5.sp,
                modifier = Modifier.padding(bottom = 16.dp)
            )
            
            // Recognized text with selectable words
            LazyColumn(
                modifier = Modifier
                    .weight(1f)
                    .fillMaxWidth()
            ) {
                items(sentences) { sentence ->
                    SentenceRow(
                        sentence = sentence,
                        selectedWord = selectedWord,
                        selectedWords = selectedWords,
                        isManualSelectionMode = isManualSelectionMode,
                        onWordClick = { word ->
                            if (isManualSelectionMode) {
                                // In manual mode, toggle selection
                                selectedWords = if (selectedWords.contains(word)) {
                                    selectedWords - word
                                } else {
                                    selectedWords + word
                                }
                            } else {
                                // Normal single word selection
                                selectedWord = word
                                cardFront = word
                                cardExample = sentence
                                
                                // Start translation with user's target language
                                scope.launch {
                                    viewModel.translateText(word, targetLanguage, settings.ocrSourceLanguage)
                                }
                            }
                        }
                    )
                    
                    Spacer(modifier = Modifier.height(12.dp))
                }
            }
            
            // Selected word info
            if (!isManualSelectionMode && selectedWord != null) {
                Spacer(modifier = Modifier.height(16.dp))
                
                Box(
                    modifier = Modifier
                        .fillMaxWidth()
                        .background(AppColors.DarkSurface, RoundedCornerShape(4.dp))
                        .border(1.dp, AppColors.Border, RoundedCornerShape(4.dp))
                        .padding(16.dp)
                ) {
                    Column {
                        Row(
                            modifier = Modifier.fillMaxWidth(),
                            horizontalArrangement = Arrangement.SpaceBetween,
                            verticalAlignment = Alignment.CenterVertically
                        ) {
                            Column(modifier = Modifier.weight(1f)) {
                                Text(
                                    text = "SELECTED WORD",
                                    fontSize = 10.sp,
                                    fontWeight = FontWeight.Bold,
                                    color = AppColors.TextPrimary.copy(alpha = 0.6f),
                                    letterSpacing = 1.sp
                                )
                                Text(
                                    text = selectedWord!!,
                                    fontSize = 18.sp,
                                    fontWeight = FontWeight.Bold,
                                    color = AppColors.TextPrimary
                                )
                            }
                            
                            IconButton(
                                onClick = { selectedWord = null }
                            ) {
                                Icon(
                                    imageVector = Icons.Default.Close,
                                    contentDescription = "Clear",
                                    tint = AppColors.TextPrimary
                                )
                            }
                        }
                        
                        // Translation
                        when (val state = translationState) {
                            is TranslationState.Translating -> {
                                Spacer(modifier = Modifier.height(8.dp))
                                Row(
                                    verticalAlignment = Alignment.CenterVertically
                                ) {
                                    CircularProgressIndicator(
                                        modifier = Modifier.size(16.dp),
                                        strokeWidth = 2.dp,
                                        color = AppColors.TextPrimary
                                    )
                                    Spacer(modifier = Modifier.width(8.dp))
                                    Text(
                                        text = "Translating...",
                                        fontSize = 12.sp,
                                        color = AppColors.TextPrimary.copy(alpha = 0.7f)
                                    )
                                }
                            }
                            is TranslationState.Success -> {
                                Spacer(modifier = Modifier.height(8.dp))
                                Row(
                                    verticalAlignment = Alignment.CenterVertically
                                ) {
                                    Icon(
                                        imageVector = Icons.Default.Translate,
                                        contentDescription = null,
                                        tint = AppColors.TextPrimary,
                                        modifier = Modifier.size(16.dp)
                                    )
                                    Spacer(modifier = Modifier.width(8.dp))
                                    Text(
                                        text = state.result.translatedText,
                                        fontSize = 14.sp,
                                        fontWeight = FontWeight.Medium,
                                        color = AppColors.TextPrimary
                                    )
                                }
                                
                                // Update card back with translation
                                LaunchedEffect(state.result.translatedText) {
                                    cardBack = state.result.translatedText
                                }
                            }
                            is TranslationState.Error -> {
                                // Translation failed, user can still create card without it
                            }
                            else -> {}
                        }
                        
                        Spacer(modifier = Modifier.height(16.dp))
                        
                        // Create Card Button
                        Box(
                            modifier = Modifier
                                .fillMaxWidth()
                                .height(48.dp)
                                .background(AppColors.DarkSurfaceVariant, RoundedCornerShape(4.dp))
                                .border(1.dp, AppColors.Border, RoundedCornerShape(4.dp))
                                .clickable {
                                    showCardDialog = true
                                },
                            contentAlignment = Alignment.Center
                        ) {
                            Row(
                                horizontalArrangement = Arrangement.Center,
                                verticalAlignment = Alignment.CenterVertically
                            ) {
                                Icon(
                                    imageVector = Icons.Default.Check,
                                    contentDescription = null,
                                    tint = AppColors.TextPrimary,
                                    modifier = Modifier.size(20.dp)
                                )
                                Spacer(modifier = Modifier.width(8.dp))
                                Text(
                                    text = "CREATE FLASHCARD",
                                    fontSize = 14.sp,
                                    fontWeight = FontWeight.Black,
                                    letterSpacing = 2.sp,
                                    color = AppColors.TextPrimary
                                )
                            }
                        }
                    }
                }
            }
            
            // Manual selection mode: Generate button
            if (isManualSelectionMode) {
                Spacer(modifier = Modifier.height(16.dp))
                Button(
                    onClick = {
                        // Trigger generation for manually selected words
                        val (sourceLang, targetLang, exampleType) = manualGenerationParams!!
                        
                        val cards = selectedWords.map { word ->
                            // Find sentence for example
                            val segments = when (exampleType) {
                                ExampleType.SENTENCE -> recognizedText.split(Regex("[.!?]\\s+"))
                                ExampleType.PHRASE -> recognizedText.split(Regex("[.,;:]\\s+"))
                                ExampleType.NONE -> emptyList()
                            }
                            val example = segments.find { it.contains(word, ignoreCase = true) }?.trim() ?: ""
                            
                            GeneratedCard(
                                front = word,
                                example = example,
                                showExampleOnFront = example.isNotBlank(),
                                showExampleOnBack = example.isNotBlank(),
                                back = "",
                                isTranslating = true
                            )
                        }
                        
                        generatedCards = cards
                        showBatchReview = true
                        isManualSelectionMode = false
                        
                        // Start translation
                        scope.launch {
                            val translatedCards = mutableListOf<GeneratedCard>()
                            cards.forEachIndexed { index, card ->
                                val result = com.betteranki.ui.ocr.TranslationManager(context).translateText(
                                    card.front,
                                    targetLang,
                                    sourceLang
                                )
                                
                                val translatedCard = result.fold(
                                    onSuccess = { translation ->
                                        card.copy(back = translation.translatedText, isTranslating = false)
                                    },
                                    onFailure = {
                                        card.copy(back = "", isTranslating = false)
                                    }
                                )
                                translatedCards.add(translatedCard)
                                generatedCards = translatedCards.toList()
                            }
                        }
                    },
                    modifier = Modifier
                        .fillMaxWidth()
                        .height(56.dp),
                    enabled = selectedWords.isNotEmpty(),
                    colors = ButtonDefaults.buttonColors(
                        containerColor = AppColors.DarkSurfaceVariant,
                        disabledContainerColor = AppColors.DarkSurfaceVariant.copy(alpha = 0.3f),
                        contentColor = AppColors.TextPrimary,
                        disabledContentColor = AppColors.TextPrimary.copy(alpha = 0.5f)
                    ),
                    shape = RoundedCornerShape(8.dp)
                ) {
                    Icon(
                        imageVector = Icons.Default.Check,
                        contentDescription = null,
                        modifier = Modifier.size(24.dp)
                    )
                    Spacer(modifier = Modifier.width(12.dp))
                    Text(
                        text = "GENERATE ${selectedWords.size} CARDS",
                        fontSize = 16.sp,
                        fontWeight = FontWeight.Black,
                        letterSpacing = 2.sp
                    )
                }
            }
            
            // Done button
            Spacer(modifier = Modifier.height(16.dp))
            Button(
                onClick = handleBackOrDone,
                modifier = Modifier
                    .fillMaxWidth()
                    .height(48.dp),
                colors = ButtonDefaults.buttonColors(
                    containerColor = AppColors.DarkSurfaceVariant
                ),
                border = BorderStroke(1.dp, AppColors.Border),
                shape = RoundedCornerShape(4.dp)
            ) {
                Text(
                    text = if (isManualSelectionMode) "CANCEL" else "DONE",
                    fontSize = 14.sp,
                    fontWeight = FontWeight.Black,
                    letterSpacing = 2.sp,
                    color = AppColors.TextPrimary
                )
            }
        }
    }
    
    // Full card creation dialog (same as manual add)
    if (showCardDialog) {
        com.betteranki.ui.decklist.AddCardDialog(
            onDismiss = {
                showCardDialog = false
                viewModel.resetTranslationState()
            },
            startWithManualEntry = true,
            initialFront = cardFront,
            initialBack = cardBack,
            initialExampleSentence = cardExample,
            initialShowExampleFront = cardExample.isNotBlank(),
            initialShowExampleBack = cardExample.isNotBlank(),
            onAddManual = { front, back, frontDesc, backDesc, imageUri, showImageFront, showImageBack, exampleSentence, showExampleFront, showExampleBack, audioUri, showAudioFront, showAudioBack ->
                scope.launch {
                    deckListViewModel.addCardSync(
                        context = context,
                        deckId = deckId,
                        front = front,
                        back = back,
                        frontDescription = frontDesc,
                        backDescription = backDesc,
                        imageUri = imageUri,
                        showImageOnFront = showImageFront,
                        showImageOnBack = showImageBack,
                        exampleSentence = exampleSentence,
                        showExampleOnFront = showExampleFront,
                        showExampleOnBack = showExampleBack,
                        audioUri = audioUri,
                        audioOnFront = showAudioFront,
                        audioOnBack = showAudioBack
                    )
                    showCardDialog = false
                    selectedWord = null
                    cardFront = ""
                    cardBack = ""
                    cardExample = ""
                    viewModel.resetTranslationState()
                    onCardCreated()
                }
            },
            onAddByPhoto = { }
        )
    }
    
    // Auto-generate cards dialog
    if (showAutoGenerateDialog) {
        AutoGenerateCardsDialog(
            fullText = recognizedText,
            sourceLanguage = settings.ocrSourceLanguage,
            defaultTargetLanguage = targetLanguage,
            onDismiss = { showAutoGenerateDialog = false },
            onGenerate = { cards, sourceLang, targetLang, exampleType ->
                showAutoGenerateDialog = false
                batchSourceLang = sourceLang
                batchTargetLang = targetLang
                
                if (cards.isEmpty()) {
                    // Manual mode - select directly from the sentence layout
                    manualGenerationParams = Triple(sourceLang, targetLang, exampleType)
                    isManualSelectionMode = true
                    selectedWords = emptySet()
                    selectedWord = null
                } else {
                    // Auto mode - proceed directly to translation and review
                    generatedCards = cards.map { it.copy(isTranslating = true) }
                    showBatchReview = true
                    
                    scope.launch {
                        val translatedCards = mutableListOf<GeneratedCard>()
                        cards.forEachIndexed { index, card ->
                            val result = com.betteranki.ui.ocr.TranslationManager(context).translateText(
                                card.front,
                                targetLang,
                                sourceLang
                            )
                            
                            val translatedCard = result.fold(
                                onSuccess = { translation ->
                                    card.copy(back = translation.translatedText, isTranslating = false)
                                },
                                onFailure = {
                                    card.copy(back = "", isTranslating = false)
                                }
                            )
                            translatedCards.add(translatedCard)
                            generatedCards = translatedCards.toList() // Update progressively
                        }
                    }
                }
            }
        )
    }
    
    // Batch review screen
    if (showBatchReview) {
        CardBatchReviewScreen(
            cards = generatedCards,
            onBack = { showBatchReview = false },
            onUpdateCard = { index, updatedCard ->
                generatedCards = generatedCards.toMutableList().apply {
                    set(index, updatedCard)
                }
            },
            onDeleteCard = { index ->
                generatedCards = generatedCards.toMutableList().apply {
                    removeAt(index)
                }
            },
            onAddAll = { cards ->
                scope.launch {
                    cards.forEach { card ->
                        deckListViewModel.addCardSync(
                            context = context,
                            deckId = deckId,
                            front = card.front,
                            back = card.back,
                            frontDescription = card.frontDescription,
                            backDescription = card.backDescription,
                            imageUri = card.imageUri,
                            showImageOnFront = card.showImageOnFront,
                            showImageOnBack = card.showImageOnBack,
                            exampleSentence = card.example,
                            showExampleOnFront = card.showExampleOnFront,
                            showExampleOnBack = card.showExampleOnBack,
                            audioUri = card.audioUri,
                            audioOnFront = card.audioOnFront,
                            audioOnBack = card.audioOnBack
                        )
                    }
                    showBatchReview = false
                    onCardCreated()
                }
            }
        )
    }
}

@OptIn(ExperimentalLayoutApi::class)
@Composable
fun SentenceRow(
    sentence: String,
    selectedWord: String?,
    selectedWords: Set<String>,
    isManualSelectionMode: Boolean,
    onWordClick: (String) -> Unit
) {
    // Split sentence into words while preserving punctuation
    val words = remember(sentence) {
        sentence.split(Regex("\\s+")).filter { it.isNotBlank() }
    }
    
    // Display as flowing text with subtle styling
    Box(
        modifier = Modifier
            .fillMaxWidth()
            .background(AppColors.DarkSurface, RoundedCornerShape(4.dp))
            .padding(12.dp)
    ) {
        FlowRow(
            modifier = Modifier.fillMaxWidth(),
            horizontalArrangement = Arrangement.spacedBy(4.dp),
            verticalArrangement = Arrangement.spacedBy(4.dp)
        ) {
            words.forEach { word ->
                val cleanWord = word.replace(Regex("[^\\w]"), "")
                if (cleanWord.isNotEmpty()) {
                    val isSelected = if (isManualSelectionMode) {
                        selectedWords.contains(cleanWord)
                    } else {
                        cleanWord == selectedWord
                    }
                    Box(
                        modifier = Modifier
                            .background(
                                color = if (isSelected)
                                    AppColors.CardNew.copy(alpha = 0.2f)
                                else
                                    Color.Transparent,
                                shape = RoundedCornerShape(2.dp)
                            )
                            .then(
                                if (isSelected) {
                                    Modifier.border(
                                        width = 1.dp,
                                        color = AppColors.CardNew.copy(alpha = 0.5f),
                                        shape = RoundedCornerShape(2.dp)
                                    )
                                } else Modifier
                            )
                            .clickable { onWordClick(cleanWord) }
                            .padding(horizontal = 4.dp, vertical = 2.dp)
                    ) {
                        Text(
                            text = word,
                            fontSize = 15.sp,
                            color = Color.White,
                            fontWeight = if (isSelected) FontWeight.SemiBold else FontWeight.Normal
                        )
                    }
                }
            }
        }
    }
}
